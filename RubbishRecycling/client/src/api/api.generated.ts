/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface IPersonLookupClient {
    /**
     * Order an AML report for a person
     * @param request Look Up Request
     * @return Returns details about the order created.
     */
    post(request: AmlPersonLookupRequest): Promise<PersonListResponseDto>;
    /**
     * Order a report for selected person
     * @return Returns details about the order created.
     */
    generateReport(reportRequest: AmlPersonLookupReportRequest): Promise<OrderDto>;
}

export class PersonLookupClient implements IPersonLookupClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Order an AML report for a person
     * @param request Look Up Request
     * @return Returns details about the order created.
     */
    post(request: AmlPersonLookupRequest): Promise<PersonListResponseDto> {
        let url_ = this.baseUrl + "/PersonLookup/order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<PersonListResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonListResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersonListResponseDto>(<any>null);
    }

    /**
     * Order a report for selected person
     * @return Returns details about the order created.
     */
    generateReport(reportRequest: AmlPersonLookupReportRequest): Promise<OrderDto> {
        let url_ = this.baseUrl + "/PersonLookup/order/report";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reportRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateReport(_response);
        });
    }

    protected processGenerateReport(response: Response): Promise<OrderDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto>(<any>null);
    }
}

export interface ICountryClient {
    /**
     * Get a list of supported countries
     */
    getSupportedCountries(): Promise<CountryDto[]>;
}

export class CountryClient implements ICountryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get a list of supported countries
     */
    getSupportedCountries(): Promise<CountryDto[]> {
        let url_ = this.baseUrl + "/Country";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSupportedCountries(_response);
        });
    }

    protected processGetSupportedCountries(response: Response): Promise<CountryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountryDto[]>(<any>null);
    }
}

export interface IHealthClient {
    /**
     * Run a health check
     */
    get(): Promise<string>;
}

export class HealthClient implements IHealthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Run a health check
     */
    get(): Promise<string> {
        let url_ = this.baseUrl + "/Health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            let resultData503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result503 = resultData503 !== undefined ? resultData503 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export interface IOrderClient {
    /**
     * Get a list of orders matching the given criteria
     * @param serviceIdentifier Service identifier (identifies which report should be ordered)
     * @param providerEntityCode Provider's unique organisation identifier (current provider is Frankie Financial)
     * @param kyckrCountryCode Country of registration. Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE)
     * @param clientReference Client reference (aka "matter")
     * @param retailerReference Retailer reference
     */
    get(serviceIdentifier: ServiceIdentifier2, providerEntityCode: string | null, kyckrCountryCode: string | null, clientReference: string | null, retailerReference: string | null): Promise<OrderDto[]>;
}

export class OrderClient implements IOrderClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get a list of orders matching the given criteria
     * @param serviceIdentifier Service identifier (identifies which report should be ordered)
     * @param providerEntityCode Provider's unique organisation identifier (current provider is Frankie Financial)
     * @param kyckrCountryCode Country of registration. Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE)
     * @param clientReference Client reference (aka "matter")
     * @param retailerReference Retailer reference
     */
    get(serviceIdentifier: ServiceIdentifier2, providerEntityCode: string | null, kyckrCountryCode: string | null, clientReference: string | null, retailerReference: string | null): Promise<OrderDto[]> {
        let url_ = this.baseUrl + "/Order?";
        if (serviceIdentifier === undefined || serviceIdentifier === null)
            throw new Error("The parameter 'serviceIdentifier' must be defined and cannot be null.");
        else
            url_ += "serviceIdentifier=" + encodeURIComponent("" + serviceIdentifier) + "&";
        if (providerEntityCode === undefined)
            throw new Error("The parameter 'providerEntityCode' must be defined.");
        else if(providerEntityCode !== null)
            url_ += "providerEntityCode=" + encodeURIComponent("" + providerEntityCode) + "&";
        if (kyckrCountryCode === undefined)
            throw new Error("The parameter 'kyckrCountryCode' must be defined.");
        else if(kyckrCountryCode !== null)
            url_ += "kyckrCountryCode=" + encodeURIComponent("" + kyckrCountryCode) + "&";
        if (clientReference === undefined)
            throw new Error("The parameter 'clientReference' must be defined.");
        else if(clientReference !== null)
            url_ += "clientReference=" + encodeURIComponent("" + clientReference) + "&";
        if (retailerReference === undefined)
            throw new Error("The parameter 'retailerReference' must be defined.");
        else if(retailerReference !== null)
            url_ += "retailerReference=" + encodeURIComponent("" + retailerReference) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<OrderDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDto.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto[]>(<any>null);
    }
}

export interface IOrganisationClient {
    /**
     * Lookup an organisation by name and/or number
     * @param name (optional) Organisation name
     * @param number (optional) Organisation number, e.g. ABN or ACN
     * @param kyckrCountryCode Country of registration. Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE)
     */
    get(name: string | null | undefined, number: string | null | undefined, kyckrCountryCode: string | null): Promise<OrganisationLiteDto[]>;
    /**
     * Order a report for an organisation
     * @param providerEntityCode Provider's unique organisation identifier (current provider is Frankie Financial)
     * @param kyckrCountryCode Country of registration. Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE)
     * @param serviceIdentifier Service identifier (identifies which report should be ordered)
     * @param clientReference Client reference (aka "matter")
     * @param retailerReference Retailer reference
     * @param quoteId (optional) Quote Id (optional)
     * @return Returns details about the order created.
     */
    post(providerEntityCode: string | null, kyckrCountryCode: string | null, serviceIdentifier: ServiceIdentifier2, clientReference: string | null, retailerReference: string | null, quoteId: string | null | undefined): Promise<OrderDto>;
}

export class OrganisationClient implements IOrganisationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Lookup an organisation by name and/or number
     * @param name (optional) Organisation name
     * @param number (optional) Organisation number, e.g. ABN or ACN
     * @param kyckrCountryCode Country of registration. Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE)
     */
    get(name: string | null | undefined, number: string | null | undefined, kyckrCountryCode: string | null): Promise<OrganisationLiteDto[]> {
        let url_ = this.baseUrl + "/Organisation?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (number !== undefined && number !== null)
            url_ += "number=" + encodeURIComponent("" + number) + "&";
        if (kyckrCountryCode === undefined)
            throw new Error("The parameter 'kyckrCountryCode' must be defined.");
        else if(kyckrCountryCode !== null)
            url_ += "kyckrCountryCode=" + encodeURIComponent("" + kyckrCountryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<OrganisationLiteDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganisationLiteDto.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganisationLiteDto[]>(<any>null);
    }

    /**
     * Order a report for an organisation
     * @param providerEntityCode Provider's unique organisation identifier (current provider is Frankie Financial)
     * @param kyckrCountryCode Country of registration. Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE)
     * @param serviceIdentifier Service identifier (identifies which report should be ordered)
     * @param clientReference Client reference (aka "matter")
     * @param retailerReference Retailer reference
     * @param quoteId (optional) Quote Id (optional)
     * @return Returns details about the order created.
     */
    post(providerEntityCode: string | null, kyckrCountryCode: string | null, serviceIdentifier: ServiceIdentifier2, clientReference: string | null, retailerReference: string | null, quoteId: string | null | undefined): Promise<OrderDto> {
        let url_ = this.baseUrl + "/Organisation/{providerEntityCode}/order?";
        if (providerEntityCode === undefined || providerEntityCode === null)
            throw new Error("The parameter 'providerEntityCode' must be defined.");
        url_ = url_.replace("{providerEntityCode}", encodeURIComponent("" + providerEntityCode));
        if (kyckrCountryCode === undefined)
            throw new Error("The parameter 'kyckrCountryCode' must be defined.");
        else if(kyckrCountryCode !== null)
            url_ += "kyckrCountryCode=" + encodeURIComponent("" + kyckrCountryCode) + "&";
        if (serviceIdentifier === undefined || serviceIdentifier === null)
            throw new Error("The parameter 'serviceIdentifier' must be defined and cannot be null.");
        else
            url_ += "serviceIdentifier=" + encodeURIComponent("" + serviceIdentifier) + "&";
        if (clientReference === undefined)
            throw new Error("The parameter 'clientReference' must be defined.");
        else if(clientReference !== null)
            url_ += "clientReference=" + encodeURIComponent("" + clientReference) + "&";
        if (retailerReference === undefined)
            throw new Error("The parameter 'retailerReference' must be defined.");
        else if(retailerReference !== null)
            url_ += "retailerReference=" + encodeURIComponent("" + retailerReference) + "&";
        if (quoteId !== undefined && quoteId !== null)
            url_ += "quoteId=" + encodeURIComponent("" + quoteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<OrderDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto>(<any>null);
    }
}

export interface IQuoteClient {
    /**
     * Get a fee quote for a ServiceIdentifier and country
     * @param kyckrCountryCode (optional) 
     */
    fee(serviceIdentifier: ServiceIdentifier2, kyckrCountryCode: string | null | undefined): Promise<QuoteDto>;
}

export class QuoteClient implements IQuoteClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get a fee quote for a ServiceIdentifier and country
     * @param kyckrCountryCode (optional) 
     */
    fee(serviceIdentifier: ServiceIdentifier2, kyckrCountryCode: string | null | undefined): Promise<QuoteDto> {
        let url_ = this.baseUrl + "/Quote?";
        if (serviceIdentifier === undefined || serviceIdentifier === null)
            throw new Error("The parameter 'serviceIdentifier' must be defined and cannot be null.");
        else
            url_ += "serviceIdentifier=" + encodeURIComponent("" + serviceIdentifier) + "&";
        if (kyckrCountryCode !== undefined && kyckrCountryCode !== null)
            url_ += "kyckrCountryCode=" + encodeURIComponent("" + kyckrCountryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFee(_response);
        });
    }

    protected processFee(response: Response): Promise<QuoteDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuoteDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QuoteDto>(<any>null);
    }
}

export interface ISystemClient {
    /**
     * Get system and region info
     */
    getSystemInfo(): Promise<SystemInfoDto>;
}

export class SystemClient implements ISystemClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get system and region info
     */
    getSystemInfo(): Promise<SystemInfoDto> {
        let url_ = this.baseUrl + "/System";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSystemInfo(_response);
        });
    }

    protected processGetSystemInfo(response: Response): Promise<SystemInfoDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemInfoDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SystemInfoDto>(<any>null);
    }
}

export interface IVersionClient {
    getApiVersion(): Promise<ApiInformationDto>;
}

export class VersionClient implements IVersionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getApiVersion(): Promise<ApiInformationDto> {
        let url_ = this.baseUrl + "/Version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApiVersion(_response);
        });
    }

    protected processGetApiVersion(response: Response): Promise<ApiInformationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiInformationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiInformationDto>(<any>null);
    }
}

/** Order info */
export class OrderDto implements IOrderDto {
    /** Order Id */
    orderId?: number;
    /** Parent order id (if any) */
    parentOrderId?: number | undefined;
    /** Order description */
    description?: string | undefined;
    /** Date the order was placed */
    dateOrdered?: Date;
    /** Date the order was completed */
    dateCompleted?: Date | undefined;
    /** Order status */
    status?: SystemStatusEnum;
    /** Status message */
    statusMessage?: string | undefined;
    /** Client reference (aka "matter") */
    clientReference?: string | undefined;
    /** Retailer reference */
    retailerReference?: string | undefined;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.parentOrderId = _data["parentOrderId"];
            this.description = _data["description"];
            this.dateOrdered = _data["dateOrdered"] ? new Date(_data["dateOrdered"].toString()) : <any>undefined;
            this.dateCompleted = _data["dateCompleted"] ? new Date(_data["dateCompleted"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.statusMessage = _data["statusMessage"];
            this.clientReference = _data["clientReference"];
            this.retailerReference = _data["retailerReference"];
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["parentOrderId"] = this.parentOrderId;
        data["description"] = this.description;
        data["dateOrdered"] = this.dateOrdered ? this.dateOrdered.toISOString() : <any>undefined;
        data["dateCompleted"] = this.dateCompleted ? this.dateCompleted.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["statusMessage"] = this.statusMessage;
        data["clientReference"] = this.clientReference;
        data["retailerReference"] = this.retailerReference;
        return data; 
    }
}

/** Order info */
export interface IOrderDto {
    /** Order Id */
    orderId?: number;
    /** Parent order id (if any) */
    parentOrderId?: number | undefined;
    /** Order description */
    description?: string | undefined;
    /** Date the order was placed */
    dateOrdered?: Date;
    /** Date the order was completed */
    dateCompleted?: Date | undefined;
    /** Order status */
    status?: SystemStatusEnum;
    /** Status message */
    statusMessage?: string | undefined;
    /** Client reference (aka "matter") */
    clientReference?: string | undefined;
    /** Retailer reference */
    retailerReference?: string | undefined;
}

/** Detailed person info */
export class PersonListResponseDto extends OrderDto implements IPersonListResponseDto {
    matches?: PersonLite[] | undefined;

    constructor(data?: IPersonListResponseDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(PersonLite.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** Detailed person info */
export interface IPersonListResponseDto extends IOrderDto {
    matches?: PersonLite[] | undefined;
}

/** Basic person info.            More info is available from the provider if required, but the structure of this object has been kept simple for now */
export class PersonLite implements IPersonLite {
    /** Provider's unique entity identifier (current provider is Frankie Financial) */
    providerEntityCode?: string | undefined;
    fullName?: string | undefined;
    /** Date of Birth of the person to look for. */
    dob?: string | undefined;
    /** Date of Birth of the person to look for. */
    yearOfBirth?: string | undefined;
    countries?: string[] | undefined;

    constructor(data?: IPersonLite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerEntityCode = _data["providerEntityCode"];
            this.fullName = _data["fullName"];
            this.dob = _data["dob"];
            this.yearOfBirth = _data["yearOfBirth"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(item);
            }
        }
    }

    static fromJS(data: any): PersonLite {
        data = typeof data === 'object' ? data : {};
        let result = new PersonLite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerEntityCode"] = this.providerEntityCode;
        data["fullName"] = this.fullName;
        data["dob"] = this.dob;
        data["yearOfBirth"] = this.yearOfBirth;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item);
        }
        return data; 
    }
}

/** Basic person info.            More info is available from the provider if required, but the structure of this object has been kept simple for now */
export interface IPersonLite {
    /** Provider's unique entity identifier (current provider is Frankie Financial) */
    providerEntityCode?: string | undefined;
    fullName?: string | undefined;
    /** Date of Birth of the person to look for. */
    dob?: string | undefined;
    /** Date of Birth of the person to look for. */
    yearOfBirth?: string | undefined;
    countries?: string[] | undefined;
}

export enum SystemStatusEnum {
    Incomplete = 1,
    Complete = 2,
    Error = 3,
    Refund = 4,
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        this.extensions![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    data["extensions"][key] = this.extensions[key];
            }
        }
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

/** Request for AML Lookup */
export class AmlPersonLookupRequest implements IAmlPersonLookupRequest {
    /** First name of person to lookup for. */
    givenName!: string;
    /** Middle name of person to lookup for. */
    middleName?: string | undefined;
    /** Last name of person to lookup for. */
    familyName!: string;
    /** Date of Birth of the person to look for. */
    dateOfBirth?: string | undefined;
    /** Year of Birth of the person to look for. */
    yearOfBirth?: string | undefined;
    serviceIdentifier?: ServiceIdentifier;
    /** Year of Birth of the person to look for. */
    clientReference?: string | undefined;
    /** Retailer reference for the client */
    retailerReference?: string | undefined;
    /** QuoteId */
    quoteId?: string | undefined;

    constructor(data?: IAmlPersonLookupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.givenName = _data["givenName"];
            this.middleName = _data["middleName"];
            this.familyName = _data["familyName"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.yearOfBirth = _data["yearOfBirth"];
            this.serviceIdentifier = _data["serviceIdentifier"];
            this.clientReference = _data["clientReference"];
            this.retailerReference = _data["retailerReference"];
            this.quoteId = _data["quoteId"];
        }
    }

    static fromJS(data: any): AmlPersonLookupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AmlPersonLookupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["givenName"] = this.givenName;
        data["middleName"] = this.middleName;
        data["familyName"] = this.familyName;
        data["dateOfBirth"] = this.dateOfBirth;
        data["yearOfBirth"] = this.yearOfBirth;
        data["serviceIdentifier"] = this.serviceIdentifier;
        data["clientReference"] = this.clientReference;
        data["retailerReference"] = this.retailerReference;
        data["quoteId"] = this.quoteId;
        return data; 
    }
}

/** Request for AML Lookup */
export interface IAmlPersonLookupRequest {
    /** First name of person to lookup for. */
    givenName: string;
    /** Middle name of person to lookup for. */
    middleName?: string | undefined;
    /** Last name of person to lookup for. */
    familyName: string;
    /** Date of Birth of the person to look for. */
    dateOfBirth?: string | undefined;
    /** Year of Birth of the person to look for. */
    yearOfBirth?: string | undefined;
    serviceIdentifier?: ServiceIdentifier;
    /** Year of Birth of the person to look for. */
    clientReference?: string | undefined;
    /** Retailer reference for the client */
    retailerReference?: string | undefined;
    /** QuoteId */
    quoteId?: string | undefined;
}

/** Service identifier (identifies which report should be ordered) */
export enum ServiceIdentifier {
    Undefined = 0,
    CddOrganisationReport = 1,
    CddPersonRiskLookup = 2,
    CddPersonRiskReport = 3,
}

export class AmlPersonLookupReportRequest implements IAmlPersonLookupReportRequest {
    /** Parent OrderId (the Id of the lookup order) */
    orderId!: number;
    /** Provider's unique entity identifiers (current provider is Frankie Financial) */
    providerEntityCodes!: string[];

    constructor(data?: IAmlPersonLookupReportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.providerEntityCodes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            if (Array.isArray(_data["providerEntityCodes"])) {
                this.providerEntityCodes = [] as any;
                for (let item of _data["providerEntityCodes"])
                    this.providerEntityCodes!.push(item);
            }
        }
    }

    static fromJS(data: any): AmlPersonLookupReportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AmlPersonLookupReportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        if (Array.isArray(this.providerEntityCodes)) {
            data["providerEntityCodes"] = [];
            for (let item of this.providerEntityCodes)
                data["providerEntityCodes"].push(item);
        }
        return data; 
    }
}

export interface IAmlPersonLookupReportRequest {
    /** Parent OrderId (the Id of the lookup order) */
    orderId: number;
    /** Provider's unique entity identifiers (current provider is Frankie Financial) */
    providerEntityCodes: string[];
}

/** A country or a state/region within a country */
export class CountryDto implements ICountryDto {
    /** Country display name */
    countryName?: string | undefined;
    /** Region display name (if applicable) */
    regionName?: string | undefined;
    /** Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE) */
    kyckrCountryCode?: string | undefined;
    /** For grouping purposes only: ISO2-compliant country code. For non-grouping purposes, please use the KyckrCountryCode instead. */
    iso2?: string | undefined;
    /** Continent or greater region (e.g. Oceania, Asia, North America, Middle East) */
    continent?: string | undefined;
    /** Country or region flag */
    flagUri?: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryName = _data["countryName"];
            this.regionName = _data["regionName"];
            this.kyckrCountryCode = _data["kyckrCountryCode"];
            this.iso2 = _data["iso2"];
            this.continent = _data["continent"];
            this.flagUri = _data["flagUri"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["regionName"] = this.regionName;
        data["kyckrCountryCode"] = this.kyckrCountryCode;
        data["iso2"] = this.iso2;
        data["continent"] = this.continent;
        data["flagUri"] = this.flagUri;
        return data; 
    }
}

/** A country or a state/region within a country */
export interface ICountryDto {
    /** Country display name */
    countryName?: string | undefined;
    /** Region display name (if applicable) */
    regionName?: string | undefined;
    /** Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE) */
    kyckrCountryCode?: string | undefined;
    /** For grouping purposes only: ISO2-compliant country code. For non-grouping purposes, please use the KyckrCountryCode instead. */
    iso2?: string | undefined;
    /** Continent or greater region (e.g. Oceania, Asia, North America, Middle East) */
    continent?: string | undefined;
    /** Country or region flag */
    flagUri?: string | undefined;
}

/** Service identifier (identifies which report should be ordered) */
export enum ServiceIdentifier2 {
    Undefined = "Undefined",
    CddOrganisationReport = "CddOrganisationReport",
    CddPersonRiskLookup = "CddPersonRiskLookup",
    CddPersonRiskReport = "CddPersonRiskReport",
}

/** Basic organisation info.            More info is available from the provider if required (e.g. aliases, addresses), but the structure of this object has been kept simple for now */
export class OrganisationLiteDto implements IOrganisationLiteDto {
    /** Organisation name */
    name?: string | undefined;
    /** Organisation number, e.g. ABN or ACN */
    number?: string | undefined;
    /** Country of registration. Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE) */
    kyckrCountryCode?: string | undefined;
    /** Provider's unique organisation identifier (current provider is Frankie Financial) */
    providerEntityCode?: string | undefined;
    /** Organisation registered address.
            
There may actually be a list of addresses, and structured data is available if necessary. So the API contract for this property can be changed if required. */
    address?: string | undefined;

    constructor(data?: IOrganisationLiteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.number = _data["number"];
            this.kyckrCountryCode = _data["kyckrCountryCode"];
            this.providerEntityCode = _data["providerEntityCode"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): OrganisationLiteDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganisationLiteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["number"] = this.number;
        data["kyckrCountryCode"] = this.kyckrCountryCode;
        data["providerEntityCode"] = this.providerEntityCode;
        data["address"] = this.address;
        return data; 
    }
}

/** Basic organisation info.            More info is available from the provider if required (e.g. aliases, addresses), but the structure of this object has been kept simple for now */
export interface IOrganisationLiteDto {
    /** Organisation name */
    name?: string | undefined;
    /** Organisation number, e.g. ABN or ACN */
    number?: string | undefined;
    /** Country of registration. Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE) */
    kyckrCountryCode?: string | undefined;
    /** Provider's unique organisation identifier (current provider is Frankie Financial) */
    providerEntityCode?: string | undefined;
    /** Organisation registered address.
            
There may actually be a list of addresses, and structured data is available if necessary. So the API contract for this property can be changed if required. */
    address?: string | undefined;
}

/** Fee quote info */
export class QuoteDto implements IQuoteDto {
    /** Fee */
    fee?: number;
    /** Service identifier (identifies which report should be ordered) */
    serviceIdentifier?: ServiceIdentifier;
    /** Country of registration. Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE) */
    kyckrCountryCode?: string | undefined;
    /** QuoteId */
    quoteId?: string;

    constructor(data?: IQuoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fee = _data["fee"];
            this.serviceIdentifier = _data["serviceIdentifier"];
            this.kyckrCountryCode = _data["kyckrCountryCode"];
            this.quoteId = _data["quoteId"];
        }
    }

    static fromJS(data: any): QuoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fee"] = this.fee;
        data["serviceIdentifier"] = this.serviceIdentifier;
        data["kyckrCountryCode"] = this.kyckrCountryCode;
        data["quoteId"] = this.quoteId;
        return data; 
    }
}

/** Fee quote info */
export interface IQuoteDto {
    /** Fee */
    fee?: number;
    /** Service identifier (identifies which report should be ordered) */
    serviceIdentifier?: ServiceIdentifier;
    /** Country of registration. Kyckr-format country code (ISO2, but with documented exceptions for USA, Canada and UAE) */
    kyckrCountryCode?: string | undefined;
    /** QuoteId */
    quoteId?: string;
}

/** System and region info */
export class SystemInfoDto implements ISystemInfoDto {
    /** Assembly name */
    name?: string | undefined;
    /** Assembly version */
    version?: string | undefined;
    /** Application name (from Serilog settings) */
    application?: string | undefined;
    /** Environment (from Serilog settings) */
    environment?: string | undefined;
    /** Region (from Serilog settings) */
    region?: string | undefined;
    /** Timezone ID */
    timeZoneId?: string | undefined;

    constructor(data?: ISystemInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.version = _data["version"];
            this.application = _data["application"];
            this.environment = _data["environment"];
            this.region = _data["region"];
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any): SystemInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["version"] = this.version;
        data["application"] = this.application;
        data["environment"] = this.environment;
        data["region"] = this.region;
        data["timeZoneId"] = this.timeZoneId;
        return data; 
    }
}

/** System and region info */
export interface ISystemInfoDto {
    /** Assembly name */
    name?: string | undefined;
    /** Assembly version */
    version?: string | undefined;
    /** Application name (from Serilog settings) */
    application?: string | undefined;
    /** Environment (from Serilog settings) */
    environment?: string | undefined;
    /** Region (from Serilog settings) */
    region?: string | undefined;
    /** Timezone ID */
    timeZoneId?: string | undefined;
}

export class ApiInformationDto implements IApiInformationDto {
    name?: string | undefined;
    version?: string | undefined;

    constructor(data?: IApiInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ApiInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["version"] = this.version;
        return data; 
    }
}

export interface IApiInformationDto {
    name?: string | undefined;
    version?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new SwaggerException(message, status, response, headers, result);
}